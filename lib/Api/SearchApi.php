<?php
/**
 * SearchApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * PAPI
 *
 * <center>                         <img src=\"https://img.cdn.level.travel/assets/logo/vector-58a947fae5d47fa53329be95ff9cff853e8889f70ac61fc2d2b6572a5998330e.svg\">                         <br><br>                         <h1>Партнёрская документация Open API</h1>                       </center>
 *
 * OpenAPI spec version: 3.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.52
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * SearchApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class SearchApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation searchEnqueueGet
     *
     * Добавление поискового запроса в очередь
     *
     * @param  string $from_city Город вылета (name_en) (required)
     * @param  string $to_country Страна назначения (ISO2) (required)
     * @param  int $adults Количество взрослых туристов (required)
     * @param  string $content_type Тип возвращаемых данных (required)
     * @param  string $authorization Токен авторизации партнера (required)
     * @param  string $accept API версия (required)
     * @param  \DateTime $start_date Дата вылета (обязателен в сочентании с nights) (optional)
     * @param  string $nights Интервал ночей (обязателен в сочентании с start_date) (optional)
     * @param  int $flex_dates Интервал +/- даты вылеты (дополнительный параметр к сочетанию start_date + nights) (optional)
     * @param  \DateTime $start_date_from Начало интервала даты вылета (обязателен в сочентании с start_date_till, end_date_from, end_date_till) (optional)
     * @param  \DateTime $start_date_till Окончание интервала даты вылета (обязателен в сочентании с start_date_from, end_date_from, end_date_till) (optional)
     * @param  \DateTime $end_date_from Начало интервала даты возвращения (обязателен в сочентании с start_date_from, start_date_till, end_date_till) (optional)
     * @param  \DateTime $end_date_till Окончание интервала даты возвращения (обязателен в сочентании с start_date_from, start_date_till, end_date_from) (optional)
     * @param  string $from_country Страна вылета (ISO2) (optional)
     * @param  string $to_city Город назначения (name_en) (optional)
     * @param  int[] $hotel_ids ID Отелей в системе (optional)
     * @param  int $kids Количество детей (optional)
     * @param  int[] $kids_ages Возраста всех детей (optional)
     * @param  string $search_type Тип поискового запроса - по турам или по отелям без перелета (optional, default to package)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse200
     */
    public function searchEnqueueGet($from_city, $to_country, $adults, $content_type, $authorization, $accept, $start_date = null, $nights = null, $flex_dates = null, $start_date_from = null, $start_date_till = null, $end_date_from = null, $end_date_till = null, $from_country = null, $to_city = null, $hotel_ids = null, $kids = null, $kids_ages = null, $search_type = 'package')
    {
        list($response) = $this->searchEnqueueGetWithHttpInfo($from_city, $to_country, $adults, $content_type, $authorization, $accept, $start_date, $nights, $flex_dates, $start_date_from, $start_date_till, $end_date_from, $end_date_till, $from_country, $to_city, $hotel_ids, $kids, $kids_ages, $search_type);
        return $response;
    }

    /**
     * Operation searchEnqueueGetWithHttpInfo
     *
     * Добавление поискового запроса в очередь
     *
     * @param  string $from_city Город вылета (name_en) (required)
     * @param  string $to_country Страна назначения (ISO2) (required)
     * @param  int $adults Количество взрослых туристов (required)
     * @param  string $content_type Тип возвращаемых данных (required)
     * @param  string $authorization Токен авторизации партнера (required)
     * @param  string $accept API версия (required)
     * @param  \DateTime $start_date Дата вылета (обязателен в сочентании с nights) (optional)
     * @param  string $nights Интервал ночей (обязателен в сочентании с start_date) (optional)
     * @param  int $flex_dates Интервал +/- даты вылеты (дополнительный параметр к сочетанию start_date + nights) (optional)
     * @param  \DateTime $start_date_from Начало интервала даты вылета (обязателен в сочентании с start_date_till, end_date_from, end_date_till) (optional)
     * @param  \DateTime $start_date_till Окончание интервала даты вылета (обязателен в сочентании с start_date_from, end_date_from, end_date_till) (optional)
     * @param  \DateTime $end_date_from Начало интервала даты возвращения (обязателен в сочентании с start_date_from, start_date_till, end_date_till) (optional)
     * @param  \DateTime $end_date_till Окончание интервала даты возвращения (обязателен в сочентании с start_date_from, start_date_till, end_date_from) (optional)
     * @param  string $from_country Страна вылета (ISO2) (optional)
     * @param  string $to_city Город назначения (name_en) (optional)
     * @param  int[] $hotel_ids ID Отелей в системе (optional)
     * @param  int $kids Количество детей (optional)
     * @param  int[] $kids_ages Возраста всех детей (optional)
     * @param  string $search_type Тип поискового запроса - по турам или по отелям без перелета (optional, default to package)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse200, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchEnqueueGetWithHttpInfo($from_city, $to_country, $adults, $content_type, $authorization, $accept, $start_date = null, $nights = null, $flex_dates = null, $start_date_from = null, $start_date_till = null, $end_date_from = null, $end_date_till = null, $from_country = null, $to_city = null, $hotel_ids = null, $kids = null, $kids_ages = null, $search_type = 'package')
    {
        $returnType = '\Swagger\Client\Model\InlineResponse200';
        $request = $this->searchEnqueueGetRequest($from_city, $to_country, $adults, $content_type, $authorization, $accept, $start_date, $nights, $flex_dates, $start_date_from, $start_date_till, $end_date_from, $end_date_till, $from_country, $to_city, $hotel_ids, $kids, $kids_ages, $search_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse200',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchEnqueueGetAsync
     *
     * Добавление поискового запроса в очередь
     *
     * @param  string $from_city Город вылета (name_en) (required)
     * @param  string $to_country Страна назначения (ISO2) (required)
     * @param  int $adults Количество взрослых туристов (required)
     * @param  string $content_type Тип возвращаемых данных (required)
     * @param  string $authorization Токен авторизации партнера (required)
     * @param  string $accept API версия (required)
     * @param  \DateTime $start_date Дата вылета (обязателен в сочентании с nights) (optional)
     * @param  string $nights Интервал ночей (обязателен в сочентании с start_date) (optional)
     * @param  int $flex_dates Интервал +/- даты вылеты (дополнительный параметр к сочетанию start_date + nights) (optional)
     * @param  \DateTime $start_date_from Начало интервала даты вылета (обязателен в сочентании с start_date_till, end_date_from, end_date_till) (optional)
     * @param  \DateTime $start_date_till Окончание интервала даты вылета (обязателен в сочентании с start_date_from, end_date_from, end_date_till) (optional)
     * @param  \DateTime $end_date_from Начало интервала даты возвращения (обязателен в сочентании с start_date_from, start_date_till, end_date_till) (optional)
     * @param  \DateTime $end_date_till Окончание интервала даты возвращения (обязателен в сочентании с start_date_from, start_date_till, end_date_from) (optional)
     * @param  string $from_country Страна вылета (ISO2) (optional)
     * @param  string $to_city Город назначения (name_en) (optional)
     * @param  int[] $hotel_ids ID Отелей в системе (optional)
     * @param  int $kids Количество детей (optional)
     * @param  int[] $kids_ages Возраста всех детей (optional)
     * @param  string $search_type Тип поискового запроса - по турам или по отелям без перелета (optional, default to package)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchEnqueueGetAsync($from_city, $to_country, $adults, $content_type, $authorization, $accept, $start_date = null, $nights = null, $flex_dates = null, $start_date_from = null, $start_date_till = null, $end_date_from = null, $end_date_till = null, $from_country = null, $to_city = null, $hotel_ids = null, $kids = null, $kids_ages = null, $search_type = 'package')
    {
        return $this->searchEnqueueGetAsyncWithHttpInfo($from_city, $to_country, $adults, $content_type, $authorization, $accept, $start_date, $nights, $flex_dates, $start_date_from, $start_date_till, $end_date_from, $end_date_till, $from_country, $to_city, $hotel_ids, $kids, $kids_ages, $search_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchEnqueueGetAsyncWithHttpInfo
     *
     * Добавление поискового запроса в очередь
     *
     * @param  string $from_city Город вылета (name_en) (required)
     * @param  string $to_country Страна назначения (ISO2) (required)
     * @param  int $adults Количество взрослых туристов (required)
     * @param  string $content_type Тип возвращаемых данных (required)
     * @param  string $authorization Токен авторизации партнера (required)
     * @param  string $accept API версия (required)
     * @param  \DateTime $start_date Дата вылета (обязателен в сочентании с nights) (optional)
     * @param  string $nights Интервал ночей (обязателен в сочентании с start_date) (optional)
     * @param  int $flex_dates Интервал +/- даты вылеты (дополнительный параметр к сочетанию start_date + nights) (optional)
     * @param  \DateTime $start_date_from Начало интервала даты вылета (обязателен в сочентании с start_date_till, end_date_from, end_date_till) (optional)
     * @param  \DateTime $start_date_till Окончание интервала даты вылета (обязателен в сочентании с start_date_from, end_date_from, end_date_till) (optional)
     * @param  \DateTime $end_date_from Начало интервала даты возвращения (обязателен в сочентании с start_date_from, start_date_till, end_date_till) (optional)
     * @param  \DateTime $end_date_till Окончание интервала даты возвращения (обязателен в сочентании с start_date_from, start_date_till, end_date_from) (optional)
     * @param  string $from_country Страна вылета (ISO2) (optional)
     * @param  string $to_city Город назначения (name_en) (optional)
     * @param  int[] $hotel_ids ID Отелей в системе (optional)
     * @param  int $kids Количество детей (optional)
     * @param  int[] $kids_ages Возраста всех детей (optional)
     * @param  string $search_type Тип поискового запроса - по турам или по отелям без перелета (optional, default to package)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchEnqueueGetAsyncWithHttpInfo($from_city, $to_country, $adults, $content_type, $authorization, $accept, $start_date = null, $nights = null, $flex_dates = null, $start_date_from = null, $start_date_till = null, $end_date_from = null, $end_date_till = null, $from_country = null, $to_city = null, $hotel_ids = null, $kids = null, $kids_ages = null, $search_type = 'package')
    {
        $returnType = '\Swagger\Client\Model\InlineResponse200';
        $request = $this->searchEnqueueGetRequest($from_city, $to_country, $adults, $content_type, $authorization, $accept, $start_date, $nights, $flex_dates, $start_date_from, $start_date_till, $end_date_from, $end_date_till, $from_country, $to_city, $hotel_ids, $kids, $kids_ages, $search_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchEnqueueGet'
     *
     * @param  string $from_city Город вылета (name_en) (required)
     * @param  string $to_country Страна назначения (ISO2) (required)
     * @param  int $adults Количество взрослых туристов (required)
     * @param  string $content_type Тип возвращаемых данных (required)
     * @param  string $authorization Токен авторизации партнера (required)
     * @param  string $accept API версия (required)
     * @param  \DateTime $start_date Дата вылета (обязателен в сочентании с nights) (optional)
     * @param  string $nights Интервал ночей (обязателен в сочентании с start_date) (optional)
     * @param  int $flex_dates Интервал +/- даты вылеты (дополнительный параметр к сочетанию start_date + nights) (optional)
     * @param  \DateTime $start_date_from Начало интервала даты вылета (обязателен в сочентании с start_date_till, end_date_from, end_date_till) (optional)
     * @param  \DateTime $start_date_till Окончание интервала даты вылета (обязателен в сочентании с start_date_from, end_date_from, end_date_till) (optional)
     * @param  \DateTime $end_date_from Начало интервала даты возвращения (обязателен в сочентании с start_date_from, start_date_till, end_date_till) (optional)
     * @param  \DateTime $end_date_till Окончание интервала даты возвращения (обязателен в сочентании с start_date_from, start_date_till, end_date_from) (optional)
     * @param  string $from_country Страна вылета (ISO2) (optional)
     * @param  string $to_city Город назначения (name_en) (optional)
     * @param  int[] $hotel_ids ID Отелей в системе (optional)
     * @param  int $kids Количество детей (optional)
     * @param  int[] $kids_ages Возраста всех детей (optional)
     * @param  string $search_type Тип поискового запроса - по турам или по отелям без перелета (optional, default to package)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchEnqueueGetRequest($from_city, $to_country, $adults, $content_type, $authorization, $accept, $start_date = null, $nights = null, $flex_dates = null, $start_date_from = null, $start_date_till = null, $end_date_from = null, $end_date_till = null, $from_country = null, $to_city = null, $hotel_ids = null, $kids = null, $kids_ages = null, $search_type = 'package')
    {
        // verify the required parameter 'from_city' is set
        if ($from_city === null || (is_array($from_city) && count($from_city) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from_city when calling searchEnqueueGet'
            );
        }
        // verify the required parameter 'to_country' is set
        if ($to_country === null || (is_array($to_country) && count($to_country) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to_country when calling searchEnqueueGet'
            );
        }
        // verify the required parameter 'adults' is set
        if ($adults === null || (is_array($adults) && count($adults) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $adults when calling searchEnqueueGet'
            );
        }
        // verify the required parameter 'content_type' is set
        if ($content_type === null || (is_array($content_type) && count($content_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content_type when calling searchEnqueueGet'
            );
        }
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling searchEnqueueGet'
            );
        }
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling searchEnqueueGet'
            );
        }

        $resourcePath = '/search/enqueue';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from_city !== null) {
            $queryParams['from_city'] = ObjectSerializer::toQueryValue($from_city, null);
        }
        // query params
        if ($to_country !== null) {
            $queryParams['to_country'] = ObjectSerializer::toQueryValue($to_country, null);
        }
        // query params
        if ($adults !== null) {
            $queryParams['adults'] = ObjectSerializer::toQueryValue($adults, 'int32');
        }
        // query params
        if ($start_date !== null) {
            $queryParams['start_date'] = ObjectSerializer::toQueryValue($start_date, 'date');
        }
        // query params
        if ($nights !== null) {
            $queryParams['nights'] = ObjectSerializer::toQueryValue($nights, null);
        }
        // query params
        if ($flex_dates !== null) {
            $queryParams['flex_dates'] = ObjectSerializer::toQueryValue($flex_dates, 'int32');
        }
        // query params
        if ($start_date_from !== null) {
            $queryParams['start_date_from'] = ObjectSerializer::toQueryValue($start_date_from, 'date');
        }
        // query params
        if ($start_date_till !== null) {
            $queryParams['start_date_till'] = ObjectSerializer::toQueryValue($start_date_till, 'date');
        }
        // query params
        if ($end_date_from !== null) {
            $queryParams['end_date_from'] = ObjectSerializer::toQueryValue($end_date_from, 'date');
        }
        // query params
        if ($end_date_till !== null) {
            $queryParams['end_date_till'] = ObjectSerializer::toQueryValue($end_date_till, 'date');
        }
        // query params
        if ($from_country !== null) {
            $queryParams['from_country'] = ObjectSerializer::toQueryValue($from_country, null);
        }
        // query params
        if ($to_city !== null) {
            $queryParams['to_city'] = ObjectSerializer::toQueryValue($to_city, null);
        }
        // query params
        if (is_array($hotel_ids)) {
            $hotel_ids = ObjectSerializer::serializeCollection($hotel_ids, 'multi', true);
        }
        if ($hotel_ids !== null) {
            $queryParams['hotel_ids'] = ObjectSerializer::toQueryValue($hotel_ids, 'int32');
        }
        // query params
        if ($kids !== null) {
            $queryParams['kids'] = ObjectSerializer::toQueryValue($kids, 'int32');
        }
        // query params
        if (is_array($kids_ages)) {
            $kids_ages = ObjectSerializer::serializeCollection($kids_ages, 'multi', true);
        }
        if ($kids_ages !== null) {
            $queryParams['kids_ages'] = ObjectSerializer::toQueryValue($kids_ages, 'int32');
        }
        // query params
        if ($search_type !== null) {
            $queryParams['search_type'] = ObjectSerializer::toQueryValue($search_type, null);
        }
        // header params
        if ($content_type !== null) {
            $headerParams['Content-Type'] = ObjectSerializer::toHeaderValue($content_type);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchGetGroupedHotelsGet
     *
     * Метод получения списка отелей
     *
     * @param  string $request_id ID запроса полученного при поиске (required)
     * @param  string $content_type Тип возвращаемых данных (required)
     * @param  string $authorization Токен авторизации партнера (required)
     * @param  string $accept API версия (required)
     * @param  float $filter_price_min Фильтр по минимальной цене (optional)
     * @param  float $filter_price_max Фильтр по максимальной цене (optional)
     * @param  string $filter_operators Массив ID операторов которых мы хотим видеть (optional)
     * @param  string $filter_stars Фильтр по количеству звезд которые хотим видеть у отебя (optional)
     * @param  bool $filter_instant_confirm Наличие моментального подтверждения (optional)
     * @param  string $filter_hotel_name Фильтр по названию отеля (optional)
     * @param  float $filter_rating Фильтр по рейтингу отеля (optional)
     * @param  float $filter_line Фильтр по расстоянию до моря (optional)
     * @param  string $filter_beach_type Фильтр по расположению пляжа (optional)
     * @param  string $filter_beach_surface Фильтр по типа пляжа, принимает массив строк (optional)
     * @param  string $filter_regions Фильтр по региону, принимает массив ID регионов (optional)
     * @param  string $filter_category Фильтр по типу отеля, принимает массив строк (optional)
     * @param  string $filter_wifi Фильтр по типу вайфая который хотим видеть в отеле, принимает массив строк (optional)
     * @param  bool $filter_pool Наличие бассейна (optional)
     * @param  bool $filter_heated_pool Наличие бассейна с подогревом (optional)
     * @param  bool $filter_aquapark Наличие аквапарка (optional)
     * @param  bool $filter_thermal_fun Наличие сауны (optional)
     * @param  bool $filter_aircon Наличие кондиционера (optional)
     * @param  bool $filter_parking Наличие парковки (optional)
     * @param  bool $filter_bar Наличие бара (optional)
     * @param  bool $filter_massage Наличие массажа (optional)
     * @param  bool $filter_nanny Наличие няни (optional)
     * @param  bool $filter_kids_menu Наличие детского меню (optional)
     * @param  bool $filter_kids_club Наличие детского клуба (optional)
     * @param  bool $filter_kids_pool Наличие детского бассейна (optional)
     * @param  string $sort_by Отсортировать выборку по выбраному параметру (optional)
     * @param  int $page_number Пагинация (optional)
     * @param  int $page_limit Пагинация (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2002
     */
    public function searchGetGroupedHotelsGet($request_id, $content_type, $authorization, $accept, $filter_price_min = null, $filter_price_max = null, $filter_operators = null, $filter_stars = null, $filter_instant_confirm = null, $filter_hotel_name = null, $filter_rating = null, $filter_line = null, $filter_beach_type = null, $filter_beach_surface = null, $filter_regions = null, $filter_category = null, $filter_wifi = null, $filter_pool = null, $filter_heated_pool = null, $filter_aquapark = null, $filter_thermal_fun = null, $filter_aircon = null, $filter_parking = null, $filter_bar = null, $filter_massage = null, $filter_nanny = null, $filter_kids_menu = null, $filter_kids_club = null, $filter_kids_pool = null, $sort_by = null, $page_number = null, $page_limit = null)
    {
        list($response) = $this->searchGetGroupedHotelsGetWithHttpInfo($request_id, $content_type, $authorization, $accept, $filter_price_min, $filter_price_max, $filter_operators, $filter_stars, $filter_instant_confirm, $filter_hotel_name, $filter_rating, $filter_line, $filter_beach_type, $filter_beach_surface, $filter_regions, $filter_category, $filter_wifi, $filter_pool, $filter_heated_pool, $filter_aquapark, $filter_thermal_fun, $filter_aircon, $filter_parking, $filter_bar, $filter_massage, $filter_nanny, $filter_kids_menu, $filter_kids_club, $filter_kids_pool, $sort_by, $page_number, $page_limit);
        return $response;
    }

    /**
     * Operation searchGetGroupedHotelsGetWithHttpInfo
     *
     * Метод получения списка отелей
     *
     * @param  string $request_id ID запроса полученного при поиске (required)
     * @param  string $content_type Тип возвращаемых данных (required)
     * @param  string $authorization Токен авторизации партнера (required)
     * @param  string $accept API версия (required)
     * @param  float $filter_price_min Фильтр по минимальной цене (optional)
     * @param  float $filter_price_max Фильтр по максимальной цене (optional)
     * @param  string $filter_operators Массив ID операторов которых мы хотим видеть (optional)
     * @param  string $filter_stars Фильтр по количеству звезд которые хотим видеть у отебя (optional)
     * @param  bool $filter_instant_confirm Наличие моментального подтверждения (optional)
     * @param  string $filter_hotel_name Фильтр по названию отеля (optional)
     * @param  float $filter_rating Фильтр по рейтингу отеля (optional)
     * @param  float $filter_line Фильтр по расстоянию до моря (optional)
     * @param  string $filter_beach_type Фильтр по расположению пляжа (optional)
     * @param  string $filter_beach_surface Фильтр по типа пляжа, принимает массив строк (optional)
     * @param  string $filter_regions Фильтр по региону, принимает массив ID регионов (optional)
     * @param  string $filter_category Фильтр по типу отеля, принимает массив строк (optional)
     * @param  string $filter_wifi Фильтр по типу вайфая который хотим видеть в отеле, принимает массив строк (optional)
     * @param  bool $filter_pool Наличие бассейна (optional)
     * @param  bool $filter_heated_pool Наличие бассейна с подогревом (optional)
     * @param  bool $filter_aquapark Наличие аквапарка (optional)
     * @param  bool $filter_thermal_fun Наличие сауны (optional)
     * @param  bool $filter_aircon Наличие кондиционера (optional)
     * @param  bool $filter_parking Наличие парковки (optional)
     * @param  bool $filter_bar Наличие бара (optional)
     * @param  bool $filter_massage Наличие массажа (optional)
     * @param  bool $filter_nanny Наличие няни (optional)
     * @param  bool $filter_kids_menu Наличие детского меню (optional)
     * @param  bool $filter_kids_club Наличие детского клуба (optional)
     * @param  bool $filter_kids_pool Наличие детского бассейна (optional)
     * @param  string $sort_by Отсортировать выборку по выбраному параметру (optional)
     * @param  int $page_number Пагинация (optional)
     * @param  int $page_limit Пагинация (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2002, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchGetGroupedHotelsGetWithHttpInfo($request_id, $content_type, $authorization, $accept, $filter_price_min = null, $filter_price_max = null, $filter_operators = null, $filter_stars = null, $filter_instant_confirm = null, $filter_hotel_name = null, $filter_rating = null, $filter_line = null, $filter_beach_type = null, $filter_beach_surface = null, $filter_regions = null, $filter_category = null, $filter_wifi = null, $filter_pool = null, $filter_heated_pool = null, $filter_aquapark = null, $filter_thermal_fun = null, $filter_aircon = null, $filter_parking = null, $filter_bar = null, $filter_massage = null, $filter_nanny = null, $filter_kids_menu = null, $filter_kids_club = null, $filter_kids_pool = null, $sort_by = null, $page_number = null, $page_limit = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2002';
        $request = $this->searchGetGroupedHotelsGetRequest($request_id, $content_type, $authorization, $accept, $filter_price_min, $filter_price_max, $filter_operators, $filter_stars, $filter_instant_confirm, $filter_hotel_name, $filter_rating, $filter_line, $filter_beach_type, $filter_beach_surface, $filter_regions, $filter_category, $filter_wifi, $filter_pool, $filter_heated_pool, $filter_aquapark, $filter_thermal_fun, $filter_aircon, $filter_parking, $filter_bar, $filter_massage, $filter_nanny, $filter_kids_menu, $filter_kids_club, $filter_kids_pool, $sort_by, $page_number, $page_limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2002',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchGetGroupedHotelsGetAsync
     *
     * Метод получения списка отелей
     *
     * @param  string $request_id ID запроса полученного при поиске (required)
     * @param  string $content_type Тип возвращаемых данных (required)
     * @param  string $authorization Токен авторизации партнера (required)
     * @param  string $accept API версия (required)
     * @param  float $filter_price_min Фильтр по минимальной цене (optional)
     * @param  float $filter_price_max Фильтр по максимальной цене (optional)
     * @param  string $filter_operators Массив ID операторов которых мы хотим видеть (optional)
     * @param  string $filter_stars Фильтр по количеству звезд которые хотим видеть у отебя (optional)
     * @param  bool $filter_instant_confirm Наличие моментального подтверждения (optional)
     * @param  string $filter_hotel_name Фильтр по названию отеля (optional)
     * @param  float $filter_rating Фильтр по рейтингу отеля (optional)
     * @param  float $filter_line Фильтр по расстоянию до моря (optional)
     * @param  string $filter_beach_type Фильтр по расположению пляжа (optional)
     * @param  string $filter_beach_surface Фильтр по типа пляжа, принимает массив строк (optional)
     * @param  string $filter_regions Фильтр по региону, принимает массив ID регионов (optional)
     * @param  string $filter_category Фильтр по типу отеля, принимает массив строк (optional)
     * @param  string $filter_wifi Фильтр по типу вайфая который хотим видеть в отеле, принимает массив строк (optional)
     * @param  bool $filter_pool Наличие бассейна (optional)
     * @param  bool $filter_heated_pool Наличие бассейна с подогревом (optional)
     * @param  bool $filter_aquapark Наличие аквапарка (optional)
     * @param  bool $filter_thermal_fun Наличие сауны (optional)
     * @param  bool $filter_aircon Наличие кондиционера (optional)
     * @param  bool $filter_parking Наличие парковки (optional)
     * @param  bool $filter_bar Наличие бара (optional)
     * @param  bool $filter_massage Наличие массажа (optional)
     * @param  bool $filter_nanny Наличие няни (optional)
     * @param  bool $filter_kids_menu Наличие детского меню (optional)
     * @param  bool $filter_kids_club Наличие детского клуба (optional)
     * @param  bool $filter_kids_pool Наличие детского бассейна (optional)
     * @param  string $sort_by Отсортировать выборку по выбраному параметру (optional)
     * @param  int $page_number Пагинация (optional)
     * @param  int $page_limit Пагинация (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchGetGroupedHotelsGetAsync($request_id, $content_type, $authorization, $accept, $filter_price_min = null, $filter_price_max = null, $filter_operators = null, $filter_stars = null, $filter_instant_confirm = null, $filter_hotel_name = null, $filter_rating = null, $filter_line = null, $filter_beach_type = null, $filter_beach_surface = null, $filter_regions = null, $filter_category = null, $filter_wifi = null, $filter_pool = null, $filter_heated_pool = null, $filter_aquapark = null, $filter_thermal_fun = null, $filter_aircon = null, $filter_parking = null, $filter_bar = null, $filter_massage = null, $filter_nanny = null, $filter_kids_menu = null, $filter_kids_club = null, $filter_kids_pool = null, $sort_by = null, $page_number = null, $page_limit = null)
    {
        return $this->searchGetGroupedHotelsGetAsyncWithHttpInfo($request_id, $content_type, $authorization, $accept, $filter_price_min, $filter_price_max, $filter_operators, $filter_stars, $filter_instant_confirm, $filter_hotel_name, $filter_rating, $filter_line, $filter_beach_type, $filter_beach_surface, $filter_regions, $filter_category, $filter_wifi, $filter_pool, $filter_heated_pool, $filter_aquapark, $filter_thermal_fun, $filter_aircon, $filter_parking, $filter_bar, $filter_massage, $filter_nanny, $filter_kids_menu, $filter_kids_club, $filter_kids_pool, $sort_by, $page_number, $page_limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchGetGroupedHotelsGetAsyncWithHttpInfo
     *
     * Метод получения списка отелей
     *
     * @param  string $request_id ID запроса полученного при поиске (required)
     * @param  string $content_type Тип возвращаемых данных (required)
     * @param  string $authorization Токен авторизации партнера (required)
     * @param  string $accept API версия (required)
     * @param  float $filter_price_min Фильтр по минимальной цене (optional)
     * @param  float $filter_price_max Фильтр по максимальной цене (optional)
     * @param  string $filter_operators Массив ID операторов которых мы хотим видеть (optional)
     * @param  string $filter_stars Фильтр по количеству звезд которые хотим видеть у отебя (optional)
     * @param  bool $filter_instant_confirm Наличие моментального подтверждения (optional)
     * @param  string $filter_hotel_name Фильтр по названию отеля (optional)
     * @param  float $filter_rating Фильтр по рейтингу отеля (optional)
     * @param  float $filter_line Фильтр по расстоянию до моря (optional)
     * @param  string $filter_beach_type Фильтр по расположению пляжа (optional)
     * @param  string $filter_beach_surface Фильтр по типа пляжа, принимает массив строк (optional)
     * @param  string $filter_regions Фильтр по региону, принимает массив ID регионов (optional)
     * @param  string $filter_category Фильтр по типу отеля, принимает массив строк (optional)
     * @param  string $filter_wifi Фильтр по типу вайфая который хотим видеть в отеле, принимает массив строк (optional)
     * @param  bool $filter_pool Наличие бассейна (optional)
     * @param  bool $filter_heated_pool Наличие бассейна с подогревом (optional)
     * @param  bool $filter_aquapark Наличие аквапарка (optional)
     * @param  bool $filter_thermal_fun Наличие сауны (optional)
     * @param  bool $filter_aircon Наличие кондиционера (optional)
     * @param  bool $filter_parking Наличие парковки (optional)
     * @param  bool $filter_bar Наличие бара (optional)
     * @param  bool $filter_massage Наличие массажа (optional)
     * @param  bool $filter_nanny Наличие няни (optional)
     * @param  bool $filter_kids_menu Наличие детского меню (optional)
     * @param  bool $filter_kids_club Наличие детского клуба (optional)
     * @param  bool $filter_kids_pool Наличие детского бассейна (optional)
     * @param  string $sort_by Отсортировать выборку по выбраному параметру (optional)
     * @param  int $page_number Пагинация (optional)
     * @param  int $page_limit Пагинация (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchGetGroupedHotelsGetAsyncWithHttpInfo($request_id, $content_type, $authorization, $accept, $filter_price_min = null, $filter_price_max = null, $filter_operators = null, $filter_stars = null, $filter_instant_confirm = null, $filter_hotel_name = null, $filter_rating = null, $filter_line = null, $filter_beach_type = null, $filter_beach_surface = null, $filter_regions = null, $filter_category = null, $filter_wifi = null, $filter_pool = null, $filter_heated_pool = null, $filter_aquapark = null, $filter_thermal_fun = null, $filter_aircon = null, $filter_parking = null, $filter_bar = null, $filter_massage = null, $filter_nanny = null, $filter_kids_menu = null, $filter_kids_club = null, $filter_kids_pool = null, $sort_by = null, $page_number = null, $page_limit = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2002';
        $request = $this->searchGetGroupedHotelsGetRequest($request_id, $content_type, $authorization, $accept, $filter_price_min, $filter_price_max, $filter_operators, $filter_stars, $filter_instant_confirm, $filter_hotel_name, $filter_rating, $filter_line, $filter_beach_type, $filter_beach_surface, $filter_regions, $filter_category, $filter_wifi, $filter_pool, $filter_heated_pool, $filter_aquapark, $filter_thermal_fun, $filter_aircon, $filter_parking, $filter_bar, $filter_massage, $filter_nanny, $filter_kids_menu, $filter_kids_club, $filter_kids_pool, $sort_by, $page_number, $page_limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchGetGroupedHotelsGet'
     *
     * @param  string $request_id ID запроса полученного при поиске (required)
     * @param  string $content_type Тип возвращаемых данных (required)
     * @param  string $authorization Токен авторизации партнера (required)
     * @param  string $accept API версия (required)
     * @param  float $filter_price_min Фильтр по минимальной цене (optional)
     * @param  float $filter_price_max Фильтр по максимальной цене (optional)
     * @param  string $filter_operators Массив ID операторов которых мы хотим видеть (optional)
     * @param  string $filter_stars Фильтр по количеству звезд которые хотим видеть у отебя (optional)
     * @param  bool $filter_instant_confirm Наличие моментального подтверждения (optional)
     * @param  string $filter_hotel_name Фильтр по названию отеля (optional)
     * @param  float $filter_rating Фильтр по рейтингу отеля (optional)
     * @param  float $filter_line Фильтр по расстоянию до моря (optional)
     * @param  string $filter_beach_type Фильтр по расположению пляжа (optional)
     * @param  string $filter_beach_surface Фильтр по типа пляжа, принимает массив строк (optional)
     * @param  string $filter_regions Фильтр по региону, принимает массив ID регионов (optional)
     * @param  string $filter_category Фильтр по типу отеля, принимает массив строк (optional)
     * @param  string $filter_wifi Фильтр по типу вайфая который хотим видеть в отеле, принимает массив строк (optional)
     * @param  bool $filter_pool Наличие бассейна (optional)
     * @param  bool $filter_heated_pool Наличие бассейна с подогревом (optional)
     * @param  bool $filter_aquapark Наличие аквапарка (optional)
     * @param  bool $filter_thermal_fun Наличие сауны (optional)
     * @param  bool $filter_aircon Наличие кондиционера (optional)
     * @param  bool $filter_parking Наличие парковки (optional)
     * @param  bool $filter_bar Наличие бара (optional)
     * @param  bool $filter_massage Наличие массажа (optional)
     * @param  bool $filter_nanny Наличие няни (optional)
     * @param  bool $filter_kids_menu Наличие детского меню (optional)
     * @param  bool $filter_kids_club Наличие детского клуба (optional)
     * @param  bool $filter_kids_pool Наличие детского бассейна (optional)
     * @param  string $sort_by Отсортировать выборку по выбраному параметру (optional)
     * @param  int $page_number Пагинация (optional)
     * @param  int $page_limit Пагинация (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchGetGroupedHotelsGetRequest($request_id, $content_type, $authorization, $accept, $filter_price_min = null, $filter_price_max = null, $filter_operators = null, $filter_stars = null, $filter_instant_confirm = null, $filter_hotel_name = null, $filter_rating = null, $filter_line = null, $filter_beach_type = null, $filter_beach_surface = null, $filter_regions = null, $filter_category = null, $filter_wifi = null, $filter_pool = null, $filter_heated_pool = null, $filter_aquapark = null, $filter_thermal_fun = null, $filter_aircon = null, $filter_parking = null, $filter_bar = null, $filter_massage = null, $filter_nanny = null, $filter_kids_menu = null, $filter_kids_club = null, $filter_kids_pool = null, $sort_by = null, $page_number = null, $page_limit = null)
    {
        // verify the required parameter 'request_id' is set
        if ($request_id === null || (is_array($request_id) && count($request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_id when calling searchGetGroupedHotelsGet'
            );
        }
        // verify the required parameter 'content_type' is set
        if ($content_type === null || (is_array($content_type) && count($content_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content_type when calling searchGetGroupedHotelsGet'
            );
        }
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling searchGetGroupedHotelsGet'
            );
        }
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling searchGetGroupedHotelsGet'
            );
        }

        $resourcePath = '/search/get_grouped_hotels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($request_id !== null) {
            $queryParams['request_id'] = ObjectSerializer::toQueryValue($request_id, null);
        }
        // query params
        if ($filter_price_min !== null) {
            $queryParams['filter_price_min'] = ObjectSerializer::toQueryValue($filter_price_min, null);
        }
        // query params
        if ($filter_price_max !== null) {
            $queryParams['filter_price_max'] = ObjectSerializer::toQueryValue($filter_price_max, null);
        }
        // query params
        if ($filter_operators !== null) {
            $queryParams['filter_operators'] = ObjectSerializer::toQueryValue($filter_operators, null);
        }
        // query params
        if ($filter_stars !== null) {
            $queryParams['filter_stars'] = ObjectSerializer::toQueryValue($filter_stars, null);
        }
        // query params
        if ($filter_instant_confirm !== null) {
            $queryParams['filter_instant_confirm'] = ObjectSerializer::toQueryValue($filter_instant_confirm, null);
        }
        // query params
        if ($filter_hotel_name !== null) {
            $queryParams['filter_hotel_name'] = ObjectSerializer::toQueryValue($filter_hotel_name, null);
        }
        // query params
        if ($filter_rating !== null) {
            $queryParams['filter_rating'] = ObjectSerializer::toQueryValue($filter_rating, null);
        }
        // query params
        if ($filter_line !== null) {
            $queryParams['filter_line'] = ObjectSerializer::toQueryValue($filter_line, null);
        }
        // query params
        if ($filter_beach_type !== null) {
            $queryParams['filter_beach_type'] = ObjectSerializer::toQueryValue($filter_beach_type, null);
        }
        // query params
        if ($filter_beach_surface !== null) {
            $queryParams['filter_beach_surface'] = ObjectSerializer::toQueryValue($filter_beach_surface, null);
        }
        // query params
        if ($filter_regions !== null) {
            $queryParams['filter_regions'] = ObjectSerializer::toQueryValue($filter_regions, null);
        }
        // query params
        if ($filter_category !== null) {
            $queryParams['filter_category'] = ObjectSerializer::toQueryValue($filter_category, null);
        }
        // query params
        if ($filter_wifi !== null) {
            $queryParams['filter_wifi'] = ObjectSerializer::toQueryValue($filter_wifi, null);
        }
        // query params
        if ($filter_pool !== null) {
            $queryParams['filter_pool'] = ObjectSerializer::toQueryValue($filter_pool, null);
        }
        // query params
        if ($filter_heated_pool !== null) {
            $queryParams['filter_heated_pool'] = ObjectSerializer::toQueryValue($filter_heated_pool, null);
        }
        // query params
        if ($filter_aquapark !== null) {
            $queryParams['filter_aquapark'] = ObjectSerializer::toQueryValue($filter_aquapark, null);
        }
        // query params
        if ($filter_thermal_fun !== null) {
            $queryParams['filter_thermal_fun'] = ObjectSerializer::toQueryValue($filter_thermal_fun, null);
        }
        // query params
        if ($filter_aircon !== null) {
            $queryParams['filter_aircon'] = ObjectSerializer::toQueryValue($filter_aircon, null);
        }
        // query params
        if ($filter_parking !== null) {
            $queryParams['filter_parking'] = ObjectSerializer::toQueryValue($filter_parking, null);
        }
        // query params
        if ($filter_bar !== null) {
            $queryParams['filter_bar'] = ObjectSerializer::toQueryValue($filter_bar, null);
        }
        // query params
        if ($filter_massage !== null) {
            $queryParams['filter_massage'] = ObjectSerializer::toQueryValue($filter_massage, null);
        }
        // query params
        if ($filter_nanny !== null) {
            $queryParams['filter_nanny'] = ObjectSerializer::toQueryValue($filter_nanny, null);
        }
        // query params
        if ($filter_kids_menu !== null) {
            $queryParams['filter_kids_menu'] = ObjectSerializer::toQueryValue($filter_kids_menu, null);
        }
        // query params
        if ($filter_kids_club !== null) {
            $queryParams['filter_kids_club'] = ObjectSerializer::toQueryValue($filter_kids_club, null);
        }
        // query params
        if ($filter_kids_pool !== null) {
            $queryParams['filter_kids_pool'] = ObjectSerializer::toQueryValue($filter_kids_pool, null);
        }
        // query params
        if ($sort_by !== null) {
            $queryParams['sort_by'] = ObjectSerializer::toQueryValue($sort_by, null);
        }
        // query params
        if ($page_number !== null) {
            $queryParams['page_number'] = ObjectSerializer::toQueryValue($page_number, null);
        }
        // query params
        if ($page_limit !== null) {
            $queryParams['page_limit'] = ObjectSerializer::toQueryValue($page_limit, null);
        }
        // header params
        if ($content_type !== null) {
            $headerParams['Content-Type'] = ObjectSerializer::toHeaderValue($content_type);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchHotelRoomsGet
     *
     * Метод получения комнат в отеле
     *
     * @param  string $request_id ID запроса полученного при поиске (required)
     * @param  string $hotel_id ID отеля в системе который мы выбрали (required)
     * @param  string $content_type Тип возвращаемых данных (required)
     * @param  string $authorization Токен авторизации партнера (required)
     * @param  string $accept API версия (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2004
     */
    public function searchHotelRoomsGet($request_id, $hotel_id, $content_type, $authorization, $accept)
    {
        list($response) = $this->searchHotelRoomsGetWithHttpInfo($request_id, $hotel_id, $content_type, $authorization, $accept);
        return $response;
    }

    /**
     * Operation searchHotelRoomsGetWithHttpInfo
     *
     * Метод получения комнат в отеле
     *
     * @param  string $request_id ID запроса полученного при поиске (required)
     * @param  string $hotel_id ID отеля в системе который мы выбрали (required)
     * @param  string $content_type Тип возвращаемых данных (required)
     * @param  string $authorization Токен авторизации партнера (required)
     * @param  string $accept API версия (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2004, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchHotelRoomsGetWithHttpInfo($request_id, $hotel_id, $content_type, $authorization, $accept)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2004';
        $request = $this->searchHotelRoomsGetRequest($request_id, $hotel_id, $content_type, $authorization, $accept);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2004',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchHotelRoomsGetAsync
     *
     * Метод получения комнат в отеле
     *
     * @param  string $request_id ID запроса полученного при поиске (required)
     * @param  string $hotel_id ID отеля в системе который мы выбрали (required)
     * @param  string $content_type Тип возвращаемых данных (required)
     * @param  string $authorization Токен авторизации партнера (required)
     * @param  string $accept API версия (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchHotelRoomsGetAsync($request_id, $hotel_id, $content_type, $authorization, $accept)
    {
        return $this->searchHotelRoomsGetAsyncWithHttpInfo($request_id, $hotel_id, $content_type, $authorization, $accept)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchHotelRoomsGetAsyncWithHttpInfo
     *
     * Метод получения комнат в отеле
     *
     * @param  string $request_id ID запроса полученного при поиске (required)
     * @param  string $hotel_id ID отеля в системе который мы выбрали (required)
     * @param  string $content_type Тип возвращаемых данных (required)
     * @param  string $authorization Токен авторизации партнера (required)
     * @param  string $accept API версия (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchHotelRoomsGetAsyncWithHttpInfo($request_id, $hotel_id, $content_type, $authorization, $accept)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2004';
        $request = $this->searchHotelRoomsGetRequest($request_id, $hotel_id, $content_type, $authorization, $accept);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchHotelRoomsGet'
     *
     * @param  string $request_id ID запроса полученного при поиске (required)
     * @param  string $hotel_id ID отеля в системе который мы выбрали (required)
     * @param  string $content_type Тип возвращаемых данных (required)
     * @param  string $authorization Токен авторизации партнера (required)
     * @param  string $accept API версия (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchHotelRoomsGetRequest($request_id, $hotel_id, $content_type, $authorization, $accept)
    {
        // verify the required parameter 'request_id' is set
        if ($request_id === null || (is_array($request_id) && count($request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_id when calling searchHotelRoomsGet'
            );
        }
        // verify the required parameter 'hotel_id' is set
        if ($hotel_id === null || (is_array($hotel_id) && count($hotel_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hotel_id when calling searchHotelRoomsGet'
            );
        }
        // verify the required parameter 'content_type' is set
        if ($content_type === null || (is_array($content_type) && count($content_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content_type when calling searchHotelRoomsGet'
            );
        }
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling searchHotelRoomsGet'
            );
        }
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling searchHotelRoomsGet'
            );
        }

        $resourcePath = '/search/hotel_rooms';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($request_id !== null) {
            $queryParams['request_id'] = ObjectSerializer::toQueryValue($request_id, null);
        }
        // query params
        if ($hotel_id !== null) {
            $queryParams['hotel_id'] = ObjectSerializer::toQueryValue($hotel_id, null);
        }
        // header params
        if ($content_type !== null) {
            $headerParams['Content-Type'] = ObjectSerializer::toHeaderValue($content_type);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchLandGet
     *
     * Получить поисковые параметры и ссылку на поиск
     *
     * @param  string $from_city Название города вылета на английском (required)
     * @param  string $to_country Страна прибытия (iso2) (required)
     * @param  int $adults Количество взрослых туристов (required)
     * @param  string $content_type Тип возвращаемых данных (required)
     * @param  string $authorization Токен авторизации партнера (required)
     * @param  string $accept API версия (required)
     * @param  int $nights Количество ночей тура (обязательно в сочетании с датой начала тура) (optional)
     * @param  \DateTime $start_date Дата начала тура (обязательно в сочетании с количеством ночей тура) (optional)
     * @param  bool $flex_dates Флаг для создания +/-2 диапазона дат вылета (может указываться в сочетании с заданной датой начала тура) (optional)
     * @param  bool $flex_nights Флаг для создания +/-2 диапазона количества ночей тура (может указываться в сочетании с заданным количеством ночей тура) (optional)
     * @param  \DateTime $start_date_from Дата начата тура ОТ (обязателен в сочетании с start_date_till + end_date_from + end_date_till) (optional)
     * @param  \DateTime $start_date_till Дата начата тура ДО (обязателен в сочетании с start_date_from + end_date_from + end_date_till) (optional)
     * @param  \DateTime $end_date_from Дата окончания тура ОТ (обязателен в сочетании с start_date_from + start_date_till + end_date_till) (optional)
     * @param  \DateTime $end_date_till Дата окончания тура ДО (обязателен в сочетании с start_date_from + start_date_till + end_date_from) (optional)
     * @param  int $kids Количество детей туристов (optional)
     * @param  string $kids_ages Возраста всех детей туристов, разделенные запятой (optional)
     * @param  string $from_country Страна вылета (iso2) (optional)
     * @param  string $to_city Название города прибытия на английском (optional)
     * @param  string $hotel_ids ID отелей в системе (разделенные заяптой) (optional)
     * @param  int $stars_from Звездность отелей ОТ (optional)
     * @param  int $stars_to Звездность отлелей ДО (optional)
     * @param  string $search_type Тип поискового запроса - по турам или по отелям без перелета (optional, default to package)
     * @param  string $host Хост (optional)
     * @param  bool $redirect Редирект на поиск (optional)
     * @param  int $api_version Версия API (optional)
     * @param  string $key API ключ партнера (optional)
     * @param  string $sign Signature key партнера (optional)
     * @param  bool $js Флаг что метод был вызван с помощью js (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2003
     */
    public function searchLandGet($from_city, $to_country, $adults, $content_type, $authorization, $accept, $nights = null, $start_date = null, $flex_dates = null, $flex_nights = null, $start_date_from = null, $start_date_till = null, $end_date_from = null, $end_date_till = null, $kids = null, $kids_ages = null, $from_country = null, $to_city = null, $hotel_ids = null, $stars_from = null, $stars_to = null, $search_type = 'package', $host = null, $redirect = null, $api_version = null, $key = null, $sign = null, $js = null)
    {
        list($response) = $this->searchLandGetWithHttpInfo($from_city, $to_country, $adults, $content_type, $authorization, $accept, $nights, $start_date, $flex_dates, $flex_nights, $start_date_from, $start_date_till, $end_date_from, $end_date_till, $kids, $kids_ages, $from_country, $to_city, $hotel_ids, $stars_from, $stars_to, $search_type, $host, $redirect, $api_version, $key, $sign, $js);
        return $response;
    }

    /**
     * Operation searchLandGetWithHttpInfo
     *
     * Получить поисковые параметры и ссылку на поиск
     *
     * @param  string $from_city Название города вылета на английском (required)
     * @param  string $to_country Страна прибытия (iso2) (required)
     * @param  int $adults Количество взрослых туристов (required)
     * @param  string $content_type Тип возвращаемых данных (required)
     * @param  string $authorization Токен авторизации партнера (required)
     * @param  string $accept API версия (required)
     * @param  int $nights Количество ночей тура (обязательно в сочетании с датой начала тура) (optional)
     * @param  \DateTime $start_date Дата начала тура (обязательно в сочетании с количеством ночей тура) (optional)
     * @param  bool $flex_dates Флаг для создания +/-2 диапазона дат вылета (может указываться в сочетании с заданной датой начала тура) (optional)
     * @param  bool $flex_nights Флаг для создания +/-2 диапазона количества ночей тура (может указываться в сочетании с заданным количеством ночей тура) (optional)
     * @param  \DateTime $start_date_from Дата начата тура ОТ (обязателен в сочетании с start_date_till + end_date_from + end_date_till) (optional)
     * @param  \DateTime $start_date_till Дата начата тура ДО (обязателен в сочетании с start_date_from + end_date_from + end_date_till) (optional)
     * @param  \DateTime $end_date_from Дата окончания тура ОТ (обязателен в сочетании с start_date_from + start_date_till + end_date_till) (optional)
     * @param  \DateTime $end_date_till Дата окончания тура ДО (обязателен в сочетании с start_date_from + start_date_till + end_date_from) (optional)
     * @param  int $kids Количество детей туристов (optional)
     * @param  string $kids_ages Возраста всех детей туристов, разделенные запятой (optional)
     * @param  string $from_country Страна вылета (iso2) (optional)
     * @param  string $to_city Название города прибытия на английском (optional)
     * @param  string $hotel_ids ID отелей в системе (разделенные заяптой) (optional)
     * @param  int $stars_from Звездность отелей ОТ (optional)
     * @param  int $stars_to Звездность отлелей ДО (optional)
     * @param  string $search_type Тип поискового запроса - по турам или по отелям без перелета (optional, default to package)
     * @param  string $host Хост (optional)
     * @param  bool $redirect Редирект на поиск (optional)
     * @param  int $api_version Версия API (optional)
     * @param  string $key API ключ партнера (optional)
     * @param  string $sign Signature key партнера (optional)
     * @param  bool $js Флаг что метод был вызван с помощью js (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2003, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchLandGetWithHttpInfo($from_city, $to_country, $adults, $content_type, $authorization, $accept, $nights = null, $start_date = null, $flex_dates = null, $flex_nights = null, $start_date_from = null, $start_date_till = null, $end_date_from = null, $end_date_till = null, $kids = null, $kids_ages = null, $from_country = null, $to_city = null, $hotel_ids = null, $stars_from = null, $stars_to = null, $search_type = 'package', $host = null, $redirect = null, $api_version = null, $key = null, $sign = null, $js = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2003';
        $request = $this->searchLandGetRequest($from_city, $to_country, $adults, $content_type, $authorization, $accept, $nights, $start_date, $flex_dates, $flex_nights, $start_date_from, $start_date_till, $end_date_from, $end_date_till, $kids, $kids_ages, $from_country, $to_city, $hotel_ids, $stars_from, $stars_to, $search_type, $host, $redirect, $api_version, $key, $sign, $js);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2003',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchLandGetAsync
     *
     * Получить поисковые параметры и ссылку на поиск
     *
     * @param  string $from_city Название города вылета на английском (required)
     * @param  string $to_country Страна прибытия (iso2) (required)
     * @param  int $adults Количество взрослых туристов (required)
     * @param  string $content_type Тип возвращаемых данных (required)
     * @param  string $authorization Токен авторизации партнера (required)
     * @param  string $accept API версия (required)
     * @param  int $nights Количество ночей тура (обязательно в сочетании с датой начала тура) (optional)
     * @param  \DateTime $start_date Дата начала тура (обязательно в сочетании с количеством ночей тура) (optional)
     * @param  bool $flex_dates Флаг для создания +/-2 диапазона дат вылета (может указываться в сочетании с заданной датой начала тура) (optional)
     * @param  bool $flex_nights Флаг для создания +/-2 диапазона количества ночей тура (может указываться в сочетании с заданным количеством ночей тура) (optional)
     * @param  \DateTime $start_date_from Дата начата тура ОТ (обязателен в сочетании с start_date_till + end_date_from + end_date_till) (optional)
     * @param  \DateTime $start_date_till Дата начата тура ДО (обязателен в сочетании с start_date_from + end_date_from + end_date_till) (optional)
     * @param  \DateTime $end_date_from Дата окончания тура ОТ (обязателен в сочетании с start_date_from + start_date_till + end_date_till) (optional)
     * @param  \DateTime $end_date_till Дата окончания тура ДО (обязателен в сочетании с start_date_from + start_date_till + end_date_from) (optional)
     * @param  int $kids Количество детей туристов (optional)
     * @param  string $kids_ages Возраста всех детей туристов, разделенные запятой (optional)
     * @param  string $from_country Страна вылета (iso2) (optional)
     * @param  string $to_city Название города прибытия на английском (optional)
     * @param  string $hotel_ids ID отелей в системе (разделенные заяптой) (optional)
     * @param  int $stars_from Звездность отелей ОТ (optional)
     * @param  int $stars_to Звездность отлелей ДО (optional)
     * @param  string $search_type Тип поискового запроса - по турам или по отелям без перелета (optional, default to package)
     * @param  string $host Хост (optional)
     * @param  bool $redirect Редирект на поиск (optional)
     * @param  int $api_version Версия API (optional)
     * @param  string $key API ключ партнера (optional)
     * @param  string $sign Signature key партнера (optional)
     * @param  bool $js Флаг что метод был вызван с помощью js (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchLandGetAsync($from_city, $to_country, $adults, $content_type, $authorization, $accept, $nights = null, $start_date = null, $flex_dates = null, $flex_nights = null, $start_date_from = null, $start_date_till = null, $end_date_from = null, $end_date_till = null, $kids = null, $kids_ages = null, $from_country = null, $to_city = null, $hotel_ids = null, $stars_from = null, $stars_to = null, $search_type = 'package', $host = null, $redirect = null, $api_version = null, $key = null, $sign = null, $js = null)
    {
        return $this->searchLandGetAsyncWithHttpInfo($from_city, $to_country, $adults, $content_type, $authorization, $accept, $nights, $start_date, $flex_dates, $flex_nights, $start_date_from, $start_date_till, $end_date_from, $end_date_till, $kids, $kids_ages, $from_country, $to_city, $hotel_ids, $stars_from, $stars_to, $search_type, $host, $redirect, $api_version, $key, $sign, $js)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchLandGetAsyncWithHttpInfo
     *
     * Получить поисковые параметры и ссылку на поиск
     *
     * @param  string $from_city Название города вылета на английском (required)
     * @param  string $to_country Страна прибытия (iso2) (required)
     * @param  int $adults Количество взрослых туристов (required)
     * @param  string $content_type Тип возвращаемых данных (required)
     * @param  string $authorization Токен авторизации партнера (required)
     * @param  string $accept API версия (required)
     * @param  int $nights Количество ночей тура (обязательно в сочетании с датой начала тура) (optional)
     * @param  \DateTime $start_date Дата начала тура (обязательно в сочетании с количеством ночей тура) (optional)
     * @param  bool $flex_dates Флаг для создания +/-2 диапазона дат вылета (может указываться в сочетании с заданной датой начала тура) (optional)
     * @param  bool $flex_nights Флаг для создания +/-2 диапазона количества ночей тура (может указываться в сочетании с заданным количеством ночей тура) (optional)
     * @param  \DateTime $start_date_from Дата начата тура ОТ (обязателен в сочетании с start_date_till + end_date_from + end_date_till) (optional)
     * @param  \DateTime $start_date_till Дата начата тура ДО (обязателен в сочетании с start_date_from + end_date_from + end_date_till) (optional)
     * @param  \DateTime $end_date_from Дата окончания тура ОТ (обязателен в сочетании с start_date_from + start_date_till + end_date_till) (optional)
     * @param  \DateTime $end_date_till Дата окончания тура ДО (обязателен в сочетании с start_date_from + start_date_till + end_date_from) (optional)
     * @param  int $kids Количество детей туристов (optional)
     * @param  string $kids_ages Возраста всех детей туристов, разделенные запятой (optional)
     * @param  string $from_country Страна вылета (iso2) (optional)
     * @param  string $to_city Название города прибытия на английском (optional)
     * @param  string $hotel_ids ID отелей в системе (разделенные заяптой) (optional)
     * @param  int $stars_from Звездность отелей ОТ (optional)
     * @param  int $stars_to Звездность отлелей ДО (optional)
     * @param  string $search_type Тип поискового запроса - по турам или по отелям без перелета (optional, default to package)
     * @param  string $host Хост (optional)
     * @param  bool $redirect Редирект на поиск (optional)
     * @param  int $api_version Версия API (optional)
     * @param  string $key API ключ партнера (optional)
     * @param  string $sign Signature key партнера (optional)
     * @param  bool $js Флаг что метод был вызван с помощью js (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchLandGetAsyncWithHttpInfo($from_city, $to_country, $adults, $content_type, $authorization, $accept, $nights = null, $start_date = null, $flex_dates = null, $flex_nights = null, $start_date_from = null, $start_date_till = null, $end_date_from = null, $end_date_till = null, $kids = null, $kids_ages = null, $from_country = null, $to_city = null, $hotel_ids = null, $stars_from = null, $stars_to = null, $search_type = 'package', $host = null, $redirect = null, $api_version = null, $key = null, $sign = null, $js = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2003';
        $request = $this->searchLandGetRequest($from_city, $to_country, $adults, $content_type, $authorization, $accept, $nights, $start_date, $flex_dates, $flex_nights, $start_date_from, $start_date_till, $end_date_from, $end_date_till, $kids, $kids_ages, $from_country, $to_city, $hotel_ids, $stars_from, $stars_to, $search_type, $host, $redirect, $api_version, $key, $sign, $js);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchLandGet'
     *
     * @param  string $from_city Название города вылета на английском (required)
     * @param  string $to_country Страна прибытия (iso2) (required)
     * @param  int $adults Количество взрослых туристов (required)
     * @param  string $content_type Тип возвращаемых данных (required)
     * @param  string $authorization Токен авторизации партнера (required)
     * @param  string $accept API версия (required)
     * @param  int $nights Количество ночей тура (обязательно в сочетании с датой начала тура) (optional)
     * @param  \DateTime $start_date Дата начала тура (обязательно в сочетании с количеством ночей тура) (optional)
     * @param  bool $flex_dates Флаг для создания +/-2 диапазона дат вылета (может указываться в сочетании с заданной датой начала тура) (optional)
     * @param  bool $flex_nights Флаг для создания +/-2 диапазона количества ночей тура (может указываться в сочетании с заданным количеством ночей тура) (optional)
     * @param  \DateTime $start_date_from Дата начата тура ОТ (обязателен в сочетании с start_date_till + end_date_from + end_date_till) (optional)
     * @param  \DateTime $start_date_till Дата начата тура ДО (обязателен в сочетании с start_date_from + end_date_from + end_date_till) (optional)
     * @param  \DateTime $end_date_from Дата окончания тура ОТ (обязателен в сочетании с start_date_from + start_date_till + end_date_till) (optional)
     * @param  \DateTime $end_date_till Дата окончания тура ДО (обязателен в сочетании с start_date_from + start_date_till + end_date_from) (optional)
     * @param  int $kids Количество детей туристов (optional)
     * @param  string $kids_ages Возраста всех детей туристов, разделенные запятой (optional)
     * @param  string $from_country Страна вылета (iso2) (optional)
     * @param  string $to_city Название города прибытия на английском (optional)
     * @param  string $hotel_ids ID отелей в системе (разделенные заяптой) (optional)
     * @param  int $stars_from Звездность отелей ОТ (optional)
     * @param  int $stars_to Звездность отлелей ДО (optional)
     * @param  string $search_type Тип поискового запроса - по турам или по отелям без перелета (optional, default to package)
     * @param  string $host Хост (optional)
     * @param  bool $redirect Редирект на поиск (optional)
     * @param  int $api_version Версия API (optional)
     * @param  string $key API ключ партнера (optional)
     * @param  string $sign Signature key партнера (optional)
     * @param  bool $js Флаг что метод был вызван с помощью js (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchLandGetRequest($from_city, $to_country, $adults, $content_type, $authorization, $accept, $nights = null, $start_date = null, $flex_dates = null, $flex_nights = null, $start_date_from = null, $start_date_till = null, $end_date_from = null, $end_date_till = null, $kids = null, $kids_ages = null, $from_country = null, $to_city = null, $hotel_ids = null, $stars_from = null, $stars_to = null, $search_type = 'package', $host = null, $redirect = null, $api_version = null, $key = null, $sign = null, $js = null)
    {
        // verify the required parameter 'from_city' is set
        if ($from_city === null || (is_array($from_city) && count($from_city) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from_city when calling searchLandGet'
            );
        }
        // verify the required parameter 'to_country' is set
        if ($to_country === null || (is_array($to_country) && count($to_country) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to_country when calling searchLandGet'
            );
        }
        // verify the required parameter 'adults' is set
        if ($adults === null || (is_array($adults) && count($adults) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $adults when calling searchLandGet'
            );
        }
        // verify the required parameter 'content_type' is set
        if ($content_type === null || (is_array($content_type) && count($content_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content_type when calling searchLandGet'
            );
        }
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling searchLandGet'
            );
        }
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling searchLandGet'
            );
        }

        $resourcePath = '/search/land';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from_city !== null) {
            $queryParams['from_city'] = ObjectSerializer::toQueryValue($from_city, null);
        }
        // query params
        if ($to_country !== null) {
            $queryParams['to_country'] = ObjectSerializer::toQueryValue($to_country, null);
        }
        // query params
        if ($adults !== null) {
            $queryParams['adults'] = ObjectSerializer::toQueryValue($adults, null);
        }
        // query params
        if ($nights !== null) {
            $queryParams['nights'] = ObjectSerializer::toQueryValue($nights, null);
        }
        // query params
        if ($start_date !== null) {
            $queryParams['start_date'] = ObjectSerializer::toQueryValue($start_date, 'date');
        }
        // query params
        if ($flex_dates !== null) {
            $queryParams['flex_dates'] = ObjectSerializer::toQueryValue($flex_dates, null);
        }
        // query params
        if ($flex_nights !== null) {
            $queryParams['flex_nights'] = ObjectSerializer::toQueryValue($flex_nights, null);
        }
        // query params
        if ($start_date_from !== null) {
            $queryParams['start_date_from'] = ObjectSerializer::toQueryValue($start_date_from, 'date');
        }
        // query params
        if ($start_date_till !== null) {
            $queryParams['start_date_till'] = ObjectSerializer::toQueryValue($start_date_till, 'date');
        }
        // query params
        if ($end_date_from !== null) {
            $queryParams['end_date_from'] = ObjectSerializer::toQueryValue($end_date_from, 'date');
        }
        // query params
        if ($end_date_till !== null) {
            $queryParams['end_date_till'] = ObjectSerializer::toQueryValue($end_date_till, 'date');
        }
        // query params
        if ($kids !== null) {
            $queryParams['kids'] = ObjectSerializer::toQueryValue($kids, null);
        }
        // query params
        if ($kids_ages !== null) {
            $queryParams['kids_ages'] = ObjectSerializer::toQueryValue($kids_ages, null);
        }
        // query params
        if ($from_country !== null) {
            $queryParams['from_country'] = ObjectSerializer::toQueryValue($from_country, null);
        }
        // query params
        if ($to_city !== null) {
            $queryParams['to_city'] = ObjectSerializer::toQueryValue($to_city, null);
        }
        // query params
        if ($hotel_ids !== null) {
            $queryParams['hotel_ids'] = ObjectSerializer::toQueryValue($hotel_ids, null);
        }
        // query params
        if ($stars_from !== null) {
            $queryParams['stars_from'] = ObjectSerializer::toQueryValue($stars_from, null);
        }
        // query params
        if ($stars_to !== null) {
            $queryParams['stars_to'] = ObjectSerializer::toQueryValue($stars_to, null);
        }
        // query params
        if ($search_type !== null) {
            $queryParams['search_type'] = ObjectSerializer::toQueryValue($search_type, null);
        }
        // query params
        if ($host !== null) {
            $queryParams['host'] = ObjectSerializer::toQueryValue($host, null);
        }
        // query params
        if ($redirect !== null) {
            $queryParams['redirect'] = ObjectSerializer::toQueryValue($redirect, null);
        }
        // query params
        if ($api_version !== null) {
            $queryParams['api_version'] = ObjectSerializer::toQueryValue($api_version, null);
        }
        // query params
        if ($key !== null) {
            $queryParams['key'] = ObjectSerializer::toQueryValue($key, null);
        }
        // query params
        if ($sign !== null) {
            $queryParams['sign'] = ObjectSerializer::toQueryValue($sign, null);
        }
        // query params
        if ($js !== null) {
            $queryParams['js'] = ObjectSerializer::toQueryValue($js, null);
        }
        // header params
        if ($content_type !== null) {
            $headerParams['Content-Type'] = ObjectSerializer::toHeaderValue($content_type);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchStatusGet
     *
     * Статус поискового запроса
     *
     * @param  string $request_id ID поискового запроса (required)
     * @param  string $content_type Тип возвращаемых данных (required)
     * @param  string $authorization Токен авторизации партнера (required)
     * @param  string $accept API версия (required)
     * @param  bool $show_size Размер запроса (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\InlineResponse2001
     */
    public function searchStatusGet($request_id, $content_type, $authorization, $accept, $show_size = null)
    {
        list($response) = $this->searchStatusGetWithHttpInfo($request_id, $content_type, $authorization, $accept, $show_size);
        return $response;
    }

    /**
     * Operation searchStatusGetWithHttpInfo
     *
     * Статус поискового запроса
     *
     * @param  string $request_id ID поискового запроса (required)
     * @param  string $content_type Тип возвращаемых данных (required)
     * @param  string $authorization Токен авторизации партнера (required)
     * @param  string $accept API версия (required)
     * @param  bool $show_size Размер запроса (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\InlineResponse2001, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchStatusGetWithHttpInfo($request_id, $content_type, $authorization, $accept, $show_size = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2001';
        $request = $this->searchStatusGetRequest($request_id, $content_type, $authorization, $accept, $show_size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\InlineResponse2001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchStatusGetAsync
     *
     * Статус поискового запроса
     *
     * @param  string $request_id ID поискового запроса (required)
     * @param  string $content_type Тип возвращаемых данных (required)
     * @param  string $authorization Токен авторизации партнера (required)
     * @param  string $accept API версия (required)
     * @param  bool $show_size Размер запроса (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchStatusGetAsync($request_id, $content_type, $authorization, $accept, $show_size = null)
    {
        return $this->searchStatusGetAsyncWithHttpInfo($request_id, $content_type, $authorization, $accept, $show_size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchStatusGetAsyncWithHttpInfo
     *
     * Статус поискового запроса
     *
     * @param  string $request_id ID поискового запроса (required)
     * @param  string $content_type Тип возвращаемых данных (required)
     * @param  string $authorization Токен авторизации партнера (required)
     * @param  string $accept API версия (required)
     * @param  bool $show_size Размер запроса (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchStatusGetAsyncWithHttpInfo($request_id, $content_type, $authorization, $accept, $show_size = null)
    {
        $returnType = '\Swagger\Client\Model\InlineResponse2001';
        $request = $this->searchStatusGetRequest($request_id, $content_type, $authorization, $accept, $show_size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchStatusGet'
     *
     * @param  string $request_id ID поискового запроса (required)
     * @param  string $content_type Тип возвращаемых данных (required)
     * @param  string $authorization Токен авторизации партнера (required)
     * @param  string $accept API версия (required)
     * @param  bool $show_size Размер запроса (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchStatusGetRequest($request_id, $content_type, $authorization, $accept, $show_size = null)
    {
        // verify the required parameter 'request_id' is set
        if ($request_id === null || (is_array($request_id) && count($request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_id when calling searchStatusGet'
            );
        }
        // verify the required parameter 'content_type' is set
        if ($content_type === null || (is_array($content_type) && count($content_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content_type when calling searchStatusGet'
            );
        }
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling searchStatusGet'
            );
        }
        // verify the required parameter 'accept' is set
        if ($accept === null || (is_array($accept) && count($accept) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $accept when calling searchStatusGet'
            );
        }

        $resourcePath = '/search/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($request_id !== null) {
            $queryParams['request_id'] = ObjectSerializer::toQueryValue($request_id, null);
        }
        // query params
        if ($show_size !== null) {
            $queryParams['show_size'] = ObjectSerializer::toQueryValue($show_size, null);
        }
        // header params
        if ($content_type !== null) {
            $headerParams['Content-Type'] = ObjectSerializer::toHeaderValue($content_type);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }
        // header params
        if ($accept !== null) {
            $headerParams['Accept'] = ObjectSerializer::toHeaderValue($accept);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
